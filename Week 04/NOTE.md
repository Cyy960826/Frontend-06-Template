学习笔记

本周学习了字符串分析算法：
字典树、KMP字符串模式匹配算法、Wildcard

一、字典树
	字典树，又称单词查找树，Trie树，是一种树形结构，是哈希表的一个变种，主要用于大量字符串的统计、排序等等。
	
	像平时查字典一样，根据首字符依次往后进行一个树状的结构。
	
	构建Trie树的基本算法也很简单，无非是逐一把每则单词的每个字母插入Trie。插入前先看前缀是否存在。如果存在，就共享，否则创建对应的节点和边。

	每个节点对应一个最大可储存字符数组。假设字典只存26个小写英文字母，那么每个节点下应该有一个长度为26的数组。换言说，可存的元素类型越多，单个节点占用内存越大。如果用字典树储存汉字，那么每个节点必须为数千个常用汉字开辟一个数组作为储存空间，占用的内存实在不是一个数量级。不过Trie树就是一种用空间换时间的数据结构，鱼和熊掌往往不可兼得。

	建树：
	①取要插入字符串的首个字符，从根节点的孩子节点开始，匹配当前字符是否已有节点，有则把指针指向该节点。无则为该字符创建节点，并把指针指向该新建节点。
	②迭代。
	③遇到要插入字符串末尾结束符时停止迭代，并把最后一个非’\0′字符对应的节点设为末端节点。

	查找：
	循环取要插入字符串的首个字符，从根节点的孩子节点开始，匹配当前字符是否已有节点，有则继续循环，无则返回False. 直至匹配到最后一个字符则完成查找。

二、KMP字符串模式匹配算法
	在网上搜索了几篇KMP字符串模式匹配算法的博客文，大都分为了“暴力蛮力法”和“KMP算法”两块去讲。

	其中，暴力法即两个字符串像物流传送带一般，主串固定，子串一步步像前移动，一位位匹配比较，直到完全匹配找到想要的结果的位置。但是，蛮力算法明显时间复杂度过高，不适合规模稍微大一些的应用环境，因此就需要改进。这里我们观察不难发现，蛮力算法之所以需要大量的时间，是因为存在大量的局部匹配，而且每次匹配一旦失配，主串和模式串的字符指针都需要回退，并从头开始下一轮的尝试。实际上，我们在整个过程中重复了很多操作，因为在完全成功匹配之前，我们曾经很大可能匹配成功过很多次部分字符。只要充分利用这些信息，就可以不需要让主串完全回退到上次开始比较的下一个字符，模式串一样的道理，这样就可以大大提高匹配算法的效率。

三、Wildcard
	即使用通配符来代替其他字符。* 表示匹配任意长度的任意字符，? 表示匹配一个任意字符。
	在带*和？的字符串中，去掉？，可理解为Wildcard是若干个KMP组成的，加上？，每一段都转为正则表达式，用exec()来操作。